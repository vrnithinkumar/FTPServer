namespace FTPServerLib

open System.IO
open System
open System.Net
open System.Net.Sockets
open System.Threading

module DirectoryHelpers =
    let pathToTest = Directory.GetCurrentDirectory()
    let directoryDetails path = 
        let dir = DirectoryInfo(path)
        
        let files = dir.GetFiles() |> Array.map string
        
        let folders = 
            dir.GetDirectories()
            |> Array.map (fun x -> x.ToString())
        Array.append files folders
    
    let getResponseToDir: string =
        let filesAndFolders =
            directoryDetails pathToTest
            |> String.concat "\n"
        ". \n..\n"+filesAndFolders
    
    let getFile file =
        let file = FileInfo(file)
        file

    let getTheCurrentDirectory =
        pathToTest



open DirectoryHelpers
module FTPCommands =
    let singleCommands = ["pwd" ; "close"; "ls" ; "help"]
    type SupportedCommands =
        | PWD
        | USER of string
        | PASS of string
        | CLOSE
        | HELP
        | LIST 
        | CD of string
        | UNSUPPORTED

    let parseFTPCommand command = 
        printfn "Parsing %s" command
        let isSingleCommand = 
            command.Split ' '
            |> Array.length < 2
        
        if isSingleCommand then
            match command.ToLower() with
            | "pwd" -> PWD
            | "close" -> CLOSE
            | "help" -> HELP
            | "list" -> LIST
            | _ -> UNSUPPORTED
        
        else
            let [| cmdName; cmdArgs |] = command.Split ' '
            match cmdName.ToLower() with
            | "user" -> let userName = cmdArgs in USER userName        // ---> USER slacker   ---> PASS XXXX   ---> PORT 192,168,150,80,14,178
            | "pass" -> let password = cmdArgs in PASS password
            | "dir" -> let directory = cmdArgs in CD directory
            | _ -> UNSUPPORTED
            
        match command.Split ' ' with
        | [| cmdName |] -> () // single command handling
        | [| cmdName; cmdArgs |] -> ()
 
    let getResponseByParsing commandString =
        let command = parseFTPCommand commandString
        printfn "Command %s is %A" commandString command
        match command with
            | CLOSE -> "Connections is closed"
            | DIR   -> getResponseToDir
            | SupportedCommands.PWD   -> getTheCurrentDirectory
            | SupportedCommands.HELP  -> "Supported Commands are \n ls \n login \n close \n help \n dir"
            | SupportedCommands.UNSUPPORTED  -> "Error! \n Not supported!"

    let getResponseToDir =
        let filesAndFolders =
            directoryDetails pathToTest
            |> String.concat "\n"
        ". \n..\n" + filesAndFolders

    type ServerReturnCodeEnum =
        | FTPServeReady = 220
        | PasswordRequest = 331 
        | UserLoggedIn = 230
        | NameSystemTyp = 215
        | Successfull = 200
        | FileStatusOkay = 150
        | ClosingDataConnection = 226
        | ClosingControlConnection = 221
        | InvalidCredential = 430

    let ``Get Server Return Message with code`` code =
        match code with
        | ServerReturnCodeEnum.FTPServeReady as s       -> sprintf "%d FTP server ready." ((int)s)
        | ServerReturnCodeEnum.PasswordRequest          -> "331 Password required." 
        | ServerReturnCodeEnum.UserLoggedIn             -> "230 user logged in."
        | ServerReturnCodeEnum.NameSystemTyp            -> "215"
        | ServerReturnCodeEnum.Successfull              -> "200 PORT command successful."
        | ServerReturnCodeEnum.FileStatusOkay           -> "150"
        | ServerReturnCodeEnum.ClosingDataConnection    -> "226 Transfer complete."
        | ServerReturnCodeEnum.ClosingControlConnection -> "221 Goodbye."
        | ServerReturnCodeEnum.InvalidCredential        -> "430 Inavalid user name or password."


open FTPCommands



// All socket and conneection related stuff.
module ServerHelpers =
    let readFromStream (stream:NetworkStream) =
        let buffer: byte [] = Array.zeroCreate 1024
        let readLen = stream.Read(buffer, 0, 1024)
        
        let asciiBuffer = System.Text.Encoding.ASCII.GetString(buffer).ToCharArray() 
        let ftpCommand = 
            let charArray: char array = asciiBuffer |> Seq.takeWhile (fun c -> c <> '\r') |> Seq.toArray
            System.String charArray
        //printfn "Received Command : %s " ftpCommand
        ftpCommand
    //let writeToSocket(socket:Socket) (data:byte array) =
      //  socket.Send(data, 0, data.Length) 
    let writeBytesToStream (stream:NetworkStream) (data:byte array) =
        stream.Write(data, 0, data.Length)
        stream.Flush()

    let writeToStream (stream:NetworkStream) (cmd:string) =
        let dataToWrite = sprintf "%s\r\n" cmd
        let msgInBytes = System.Text.Encoding.ASCII.GetBytes(dataToWrite);  
        writeBytesToStream stream msgInBytes
        
        
    let readCommand =
        readFromStream >> parseFTPCommand
    
    let RespondWithServerCode  (stream:NetworkStream) code =
        GetServerReturnMessageWithCode code 
        |> writeToStream stream

module UserSession =
    open ServerHelpers
    /// this is ran after the user successfully logged in
    let startUserSession userName (stream:NetworkStream) =
        // parse commands
        // do stuff
        let rec readAndParseCommand () =
            let mutable port = None        // ---> PORT 192,168,150,80,14,178
            let cmd = readCommand stream
            match cmd with
            | USER user -> failwithf "shouldn't call USER command with args:[%s]" user
            | PASS pass -> failwithf "shouldn't call PASS command with args:[%s]" pass
            | HELP -> writeToStream stream true "Help just google it dude!"
            | CLOSE -> RespondWithServerCode stream ServerReturnCodeEnum.ClosingControlConnection
            | UNSUPPORTED -> writeToStream stream true "Unsupported command!"
            | LIST ->  writeToStream stream true getResponseToDir
            | _ -> writeToStream stream true "Unable to find the proper command!"
            
            match cmd with
            | CLOSE -> exit 0                   
            | _ -> readAndParseCommand ()

        readAndParseCommand () 
        
    
    let handleUserLogin (userName:string, stream:NetworkStream) = 
        "Welocome User : " + userName |>  writeToStream stream false
        // ---> USER slacker
        // 331 Password required for slacker.
        RespondWithServerCode stream ServerReturnCodeEnum.PasswordRequest
        let command = readCommand stream
        match command with
            | PASS passwd -> 
                if(passwd = "test") then 
                    RespondWithServerCode stream ServerReturnCodeEnum.Successfull
                    startUserSession userName stream 
                else 
                    RespondWithServerCode stream ServerReturnCodeEnum.InvalidCredential
            | _ -> RespondWithServerCode stream ServerReturnCodeEnum.PasswordRequest
    
    let createSession (socket:Socket): Async<unit> =
        async {
            let stream = new NetworkStream(socket, false) 
            writeToStream stream false "Connected to FTP server by F#! \n"  
            //RespondWithServerCode stream ServerReturnCodeEnum.FTPServeReady
            while true do
                let command = readCommand stream
                match command with
                | USER userName -> handleUserLogin (userName, stream)
                | _ -> writeToStream stream true "Login with USER command!."  
    
            stream.Close()
            socket.Shutdown(SocketShutdown.Both)
            socket.Close()
        }

module Main =
    open UserSession
    let commandPort = 2121
    let localHost = "127.0.0.1"
    let StartServer() =
        let commandLocalEndPoint = IPEndPoint(IPAddress.Parse(localHost), commandPort)  
        let socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
        socket.Bind(commandLocalEndPoint)
        socket.Listen(111)  
        printfn "Waiting for request ..."
        
        let connectionLimit = 10
        let connectionCount = ref 0
        
        while !connectionCount < connectionLimit do
            let socket1 = socket.Accept()
            incr connectionCount    // increase value of connectionCount by 1
            
            let cancellationSource = new CancellationTokenSource()
            let sessionAsync = createSession socket1
                               
            Async.StartWithContinuations (sessionAsync, (fun () -> decr connectionCount), // decrease by 1
                                                        (fun (x:exn) -> printfn "%s \n%s" x.Message x.StackTrace
                                                                        decr connectionCount),
                                                        (fun (x:OperationCanceledException) -> printfn "session cancelled"
                                                                                               decr connectionCount)) 
            
        printfn "Finally finished!"